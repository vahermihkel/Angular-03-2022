{"version":3,"sources":["c:/Users/vahermih/koolitused/Angular-03-2022/angular-bakeryshop/node_modules/ngx-bootstrap/tabs/bundles/ngx-bootstrap-tabs.umd.js"],"names":[],"mappings":"AAAA;4LACwI;8JACZ;;qDAErF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;WA+BhC,AAKD;;;;;;;;;;;;;;;;gCAOA;;;;;;;;;;;;;;SAcD;;;;kDAGC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UAwTA,AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;uKAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;UA2HA,AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAkBA;;;;;;;;;;;;;;;SAeD,AAGC;;;;;;;;;;4FAKG;;;;;;;;;;;;;;;;;;;;;;UAsBH;;;;;;;;;;;;;;;;;;;;;;;;;;;sKAiBA","file":"ngx-bootstrap-tabs.umd.js","sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :\n    typeof define === 'function' && define.amd ? define('ngx-bootstrap/tabs', ['exports', '@angular/core', '@angular/common'], factory) :\n    (global = global || self, factory((global['ngx-bootstrap'] = global['ngx-bootstrap'] || {}, global['ngx-bootstrap'].tabs = {}), global.ng.core, global.ng.common));\n}(this, function (exports, core, common) { 'use strict';\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var NgTranscludeDirective = /** @class */ (function () {\n        function NgTranscludeDirective(viewRef) {\n            this.viewRef = viewRef;\n        }\n        Object.defineProperty(NgTranscludeDirective.prototype, \"ngTransclude\", {\n            /* tslint:disable-next-line:no-any */\n            get: /* tslint:disable-next-line:no-any */\n            /**\n             * @return {?}\n             */\n            function () {\n                return this._ngTransclude;\n            },\n            set: /**\n             * @param {?} templateRef\n             * @return {?}\n             */\n            function (templateRef) {\n                this._ngTransclude = templateRef;\n                if (templateRef) {\n                    this.viewRef.createEmbeddedView(templateRef);\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        NgTranscludeDirective.decorators = [\n            { type: core.Directive, args: [{\n                        selector: '[ngTransclude]'\n                    },] }\n        ];\n        /** @nocollapse */\n        NgTranscludeDirective.ctorParameters = function () { return [\n            { type: core.ViewContainerRef }\n        ]; };\n        NgTranscludeDirective.propDecorators = {\n            ngTransclude: [{ type: core.Input }]\n        };\n        return NgTranscludeDirective;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var TabsetConfig = /** @class */ (function () {\n        function TabsetConfig() {\n            /**\n             * provides default navigation context class: 'tabs' or 'pills'\n             */\n            this.type = 'tabs';\n        }\n        TabsetConfig.decorators = [\n            { type: core.Injectable }\n        ];\n        return TabsetConfig;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    // todo: add active event to tab\n    // todo: fix? mixing static and dynamic tabs position tabs in order of creation\n    var TabsetComponent = /** @class */ (function () {\n        function TabsetComponent(config, renderer, elementRef) {\n            this.renderer = renderer;\n            this.elementRef = elementRef;\n            this.clazz = true;\n            this.tabs = [];\n            this.classMap = {};\n            Object.assign(this, config);\n        }\n        Object.defineProperty(TabsetComponent.prototype, \"vertical\", {\n            /** if true tabs will be placed vertically */\n            get: /**\n             * if true tabs will be placed vertically\n             * @return {?}\n             */\n            function () {\n                return this._vertical;\n            },\n            set: /**\n             * @param {?} value\n             * @return {?}\n             */\n            function (value) {\n                this._vertical = value;\n                this.setClassMap();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TabsetComponent.prototype, \"justified\", {\n            /** if true tabs fill the container and have a consistent width */\n            get: /**\n             * if true tabs fill the container and have a consistent width\n             * @return {?}\n             */\n            function () {\n                return this._justified;\n            },\n            set: /**\n             * @param {?} value\n             * @return {?}\n             */\n            function (value) {\n                this._justified = value;\n                this.setClassMap();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TabsetComponent.prototype, \"type\", {\n            /** navigation context class: 'tabs' or 'pills' */\n            get: /**\n             * navigation context class: 'tabs' or 'pills'\n             * @return {?}\n             */\n            function () {\n                return this._type;\n            },\n            set: /**\n             * @param {?} value\n             * @return {?}\n             */\n            function (value) {\n                this._type = value;\n                this.setClassMap();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @return {?}\n         */\n        TabsetComponent.prototype.ngOnDestroy = /**\n         * @return {?}\n         */\n        function () {\n            this.isDestroyed = true;\n        };\n        /**\n         * @param {?} tab\n         * @return {?}\n         */\n        TabsetComponent.prototype.addTab = /**\n         * @param {?} tab\n         * @return {?}\n         */\n        function (tab) {\n            this.tabs.push(tab);\n            tab.active = this.tabs.length === 1 && typeof tab.active === 'undefined';\n        };\n        /**\n         * @param {?} tab\n         * @param {?=} options\n         * @return {?}\n         */\n        TabsetComponent.prototype.removeTab = /**\n         * @param {?} tab\n         * @param {?=} options\n         * @return {?}\n         */\n        function (tab, options) {\n            if (options === void 0) { options = { reselect: true, emit: true }; }\n            /** @type {?} */\n            var index = this.tabs.indexOf(tab);\n            if (index === -1 || this.isDestroyed) {\n                return;\n            }\n            // Select a new tab if the tab to be removed is selected and not destroyed\n            if (options.reselect && tab.active && this.hasAvailableTabs(index)) {\n                /** @type {?} */\n                var newActiveIndex = this.getClosestTabIndex(index);\n                this.tabs[newActiveIndex].active = true;\n            }\n            if (options.emit) {\n                tab.removed.emit(tab);\n            }\n            this.tabs.splice(index, 1);\n            if (tab.elementRef.nativeElement.parentNode) {\n                this.renderer.removeChild(tab.elementRef.nativeElement.parentNode, tab.elementRef.nativeElement);\n            }\n        };\n        /* tslint:disable-next-line: cyclomatic-complexity */\n        /* tslint:disable-next-line: cyclomatic-complexity */\n        /**\n         * @param {?} event\n         * @param {?} index\n         * @return {?}\n         */\n        TabsetComponent.prototype.keyNavActions = /* tslint:disable-next-line: cyclomatic-complexity */\n        /**\n         * @param {?} event\n         * @param {?} index\n         * @return {?}\n         */\n        function (event, index) {\n            /** @type {?} */\n            var list = Array.from(this.elementRef.nativeElement.querySelectorAll('.nav-link'));\n            // const activeElList = list.filter((el: HTMLElement) => !el.classList.contains('disabled'));\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 13 || event.key === 'Enter' || event.keyCode === 32 || event.key === 'Space') {\n                event.preventDefault();\n                /** @type {?} */\n                var currentTab = list[(index) % list.length];\n                currentTab.click();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 39 || event.key === 'RightArrow') {\n                /** @type {?} */\n                var nextTab = void 0;\n                /** @type {?} */\n                var shift = 1;\n                do {\n                    nextTab = list[(index + shift) % list.length];\n                    shift++;\n                } while (nextTab.classList.contains('disabled'));\n                nextTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 37 || event.key === 'LeftArrow') {\n                /** @type {?} */\n                var previousTab = void 0;\n                /** @type {?} */\n                var shift = 1;\n                /** @type {?} */\n                var i = index;\n                do {\n                    if ((i - shift) < 0) {\n                        i = list.length - 1;\n                        previousTab = list[i];\n                        shift = 0;\n                    }\n                    else {\n                        previousTab = list[i - shift];\n                    }\n                    shift++;\n                } while (previousTab.classList.contains('disabled'));\n                previousTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 36 || event.key === 'Home') {\n                event.preventDefault();\n                /** @type {?} */\n                var firstTab = void 0;\n                /** @type {?} */\n                var shift = 0;\n                do {\n                    firstTab = list[shift % list.length];\n                    shift++;\n                } while (firstTab.classList.contains('disabled'));\n                firstTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 35 || event.key === 'End') {\n                event.preventDefault();\n                /** @type {?} */\n                var lastTab = void 0;\n                /** @type {?} */\n                var shift = 1;\n                /** @type {?} */\n                var i = index;\n                do {\n                    if ((i - shift) < 0) {\n                        i = list.length - 1;\n                        lastTab = list[i];\n                        shift = 0;\n                    }\n                    else {\n                        lastTab = list[i - shift];\n                    }\n                    shift++;\n                } while (lastTab.classList.contains('disabled'));\n                lastTab.focus();\n                return;\n            }\n            // tslint:disable-next-line:deprecation\n            if (event.keyCode === 46 || event.key === 'Delete') {\n                if (this.tabs[index].removable) {\n                    this.removeTab(this.tabs[index]);\n                    if (list[index + 1]) {\n                        list[(index + 1) % list.length].focus();\n                        return;\n                    }\n                    if (list[list.length - 1]) {\n                        list[0].focus();\n                    }\n                }\n            }\n        };\n        /**\n         * @protected\n         * @param {?} index\n         * @return {?}\n         */\n        TabsetComponent.prototype.getClosestTabIndex = /**\n         * @protected\n         * @param {?} index\n         * @return {?}\n         */\n        function (index) {\n            /** @type {?} */\n            var tabsLength = this.tabs.length;\n            if (!tabsLength) {\n                return -1;\n            }\n            for (var step = 1; step <= tabsLength; step += 1) {\n                /** @type {?} */\n                var prevIndex = index - step;\n                /** @type {?} */\n                var nextIndex = index + step;\n                if (this.tabs[prevIndex] && !this.tabs[prevIndex].disabled) {\n                    return prevIndex;\n                }\n                if (this.tabs[nextIndex] && !this.tabs[nextIndex].disabled) {\n                    return nextIndex;\n                }\n            }\n            return -1;\n        };\n        /**\n         * @protected\n         * @param {?} index\n         * @return {?}\n         */\n        TabsetComponent.prototype.hasAvailableTabs = /**\n         * @protected\n         * @param {?} index\n         * @return {?}\n         */\n        function (index) {\n            /** @type {?} */\n            var tabsLength = this.tabs.length;\n            if (!tabsLength) {\n                return false;\n            }\n            for (var i = 0; i < tabsLength; i += 1) {\n                if (!this.tabs[i].disabled && i !== index) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        /**\n         * @protected\n         * @return {?}\n         */\n        TabsetComponent.prototype.setClassMap = /**\n         * @protected\n         * @return {?}\n         */\n        function () {\n            var _a;\n            this.classMap = (_a = {\n                    'nav-stacked': this.vertical,\n                    'flex-column': this.vertical,\n                    'nav-justified': this.justified\n                },\n                _a[\"nav-\" + this.type] = true,\n                _a);\n        };\n        TabsetComponent.decorators = [\n            { type: core.Component, args: [{\n                        selector: 'tabset',\n                        template: \"<ul class=\\\"nav\\\" [ngClass]=\\\"classMap\\\" (click)=\\\"$event.preventDefault()\\\">\\n  <li *ngFor=\\\"let tabz of tabs; let i = index\\\" [ngClass]=\\\"['nav-item', tabz.customClass || '']\\\"\\n      [class.active]=\\\"tabz.active\\\" [class.disabled]=\\\"tabz.disabled\\\" (keydown)=\\\"keyNavActions($event, i)\\\">\\n    <a href=\\\"javascript:void(0);\\\" class=\\\"nav-link\\\"\\n       [attr.id]=\\\"tabz.id ? tabz.id + '-link' : ''\\\"\\n       [class.active]=\\\"tabz.active\\\" [class.disabled]=\\\"tabz.disabled\\\"\\n       (click)=\\\"tabz.active = true\\\">\\n      <span [ngTransclude]=\\\"tabz.headingRef\\\">{{ tabz.heading }}</span>\\n      <span *ngIf=\\\"tabz.removable\\\" (click)=\\\"$event.preventDefault(); removeTab(tabz);\\\" class=\\\"bs-remove-tab\\\"> &#10060;</span>\\n    </a>\\n  </li>\\n</ul>\\n<div class=\\\"tab-content\\\">\\n  <ng-content></ng-content>\\n</div>\\n\",\n                        styles: [\":host .nav-tabs .nav-item.disabled a.disabled{cursor:default}\"]\n                    }] }\n        ];\n        /** @nocollapse */\n        TabsetComponent.ctorParameters = function () { return [\n            { type: TabsetConfig },\n            { type: core.Renderer2 },\n            { type: core.ElementRef }\n        ]; };\n        TabsetComponent.propDecorators = {\n            vertical: [{ type: core.Input }],\n            justified: [{ type: core.Input }],\n            type: [{ type: core.Input }],\n            clazz: [{ type: core.HostBinding, args: ['class.tab-container',] }]\n        };\n        return TabsetComponent;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var TabDirective = /** @class */ (function () {\n        function TabDirective(tabset, elementRef, renderer) {\n            this.elementRef = elementRef;\n            this.renderer = renderer;\n            /**\n             * fired when tab became active, $event:Tab equals to selected instance of Tab component\n             */\n            this.selectTab = new core.EventEmitter();\n            /**\n             * fired when tab became inactive, $event:Tab equals to deselected instance of Tab component\n             */\n            this.deselect = new core.EventEmitter();\n            /**\n             * fired before tab will be removed, $event:Tab equals to instance of removed tab\n             */\n            this.removed = new core.EventEmitter();\n            this.addClass = true;\n            this.tabset = tabset;\n            this.tabset.addTab(this);\n        }\n        Object.defineProperty(TabDirective.prototype, \"customClass\", {\n            /** if set, will be added to the tab's class attribute. Multiple classes are supported. */\n            get: /**\n             * if set, will be added to the tab's class attribute. Multiple classes are supported.\n             * @return {?}\n             */\n            function () {\n                return this._customClass;\n            },\n            set: /**\n             * @param {?} customClass\n             * @return {?}\n             */\n            function (customClass) {\n                var _this = this;\n                if (this.customClass) {\n                    this.customClass.split(' ').forEach((/**\n                     * @param {?} cssClass\n                     * @return {?}\n                     */\n                    function (cssClass) {\n                        _this.renderer.removeClass(_this.elementRef.nativeElement, cssClass);\n                    }));\n                }\n                this._customClass = customClass ? customClass.trim() : null;\n                if (this.customClass) {\n                    this.customClass.split(' ').forEach((/**\n                     * @param {?} cssClass\n                     * @return {?}\n                     */\n                    function (cssClass) {\n                        _this.renderer.addClass(_this.elementRef.nativeElement, cssClass);\n                    }));\n                }\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(TabDirective.prototype, \"active\", {\n            /** tab active state toggle */\n            get: /**\n             * tab active state toggle\n             * @return {?}\n             */\n            function () {\n                return this._active;\n            },\n            set: /**\n             * @param {?} active\n             * @return {?}\n             */\n            function (active) {\n                var _this = this;\n                if (this._active === active) {\n                    return;\n                }\n                if ((this.disabled && active) || !active) {\n                    if (this._active && !active) {\n                        this.deselect.emit(this);\n                        this._active = active;\n                    }\n                    return;\n                }\n                this._active = active;\n                this.selectTab.emit(this);\n                this.tabset.tabs.forEach((/**\n                 * @param {?} tab\n                 * @return {?}\n                 */\n                function (tab) {\n                    if (tab !== _this) {\n                        tab.active = false;\n                    }\n                }));\n            },\n            enumerable: true,\n            configurable: true\n        });\n        /**\n         * @return {?}\n         */\n        TabDirective.prototype.ngOnInit = /**\n         * @return {?}\n         */\n        function () {\n            this.removable = this.removable;\n        };\n        /**\n         * @return {?}\n         */\n        TabDirective.prototype.ngOnDestroy = /**\n         * @return {?}\n         */\n        function () {\n            this.tabset.removeTab(this, { reselect: false, emit: false });\n        };\n        TabDirective.decorators = [\n            { type: core.Directive, args: [{ selector: 'tab, [tab]' },] }\n        ];\n        /** @nocollapse */\n        TabDirective.ctorParameters = function () { return [\n            { type: TabsetComponent },\n            { type: core.ElementRef },\n            { type: core.Renderer2 }\n        ]; };\n        TabDirective.propDecorators = {\n            heading: [{ type: core.Input }],\n            id: [{ type: core.HostBinding, args: ['attr.id',] }, { type: core.Input }],\n            disabled: [{ type: core.Input }],\n            removable: [{ type: core.Input }],\n            customClass: [{ type: core.Input }],\n            active: [{ type: core.HostBinding, args: ['class.active',] }, { type: core.Input }],\n            selectTab: [{ type: core.Output }],\n            deselect: [{ type: core.Output }],\n            removed: [{ type: core.Output }],\n            addClass: [{ type: core.HostBinding, args: ['class.tab-pane',] }]\n        };\n        return TabDirective;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    /**\n     * Should be used to mark <ng-template> element as a template for tab heading\n     */\n    var TabHeadingDirective = /** @class */ (function () {\n        /* tslint:disable-next-line:no-any */\n        function TabHeadingDirective(templateRef, tab) {\n            tab.headingRef = templateRef;\n        }\n        TabHeadingDirective.decorators = [\n            { type: core.Directive, args: [{ selector: '[tabHeading]' },] }\n        ];\n        /** @nocollapse */\n        TabHeadingDirective.ctorParameters = function () { return [\n            { type: core.TemplateRef },\n            { type: TabDirective }\n        ]; };\n        return TabHeadingDirective;\n    }());\n\n    /**\n     * @fileoverview added by tsickle\n     * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n     */\n    var TabsModule = /** @class */ (function () {\n        function TabsModule() {\n        }\n        /**\n         * @return {?}\n         */\n        TabsModule.forRoot = /**\n         * @return {?}\n         */\n        function () {\n            return {\n                ngModule: TabsModule,\n                providers: [TabsetConfig]\n            };\n        };\n        TabsModule.decorators = [\n            { type: core.NgModule, args: [{\n                        imports: [common.CommonModule],\n                        declarations: [\n                            NgTranscludeDirective,\n                            TabDirective,\n                            TabsetComponent,\n                            TabHeadingDirective\n                        ],\n                        exports: [\n                            TabDirective,\n                            TabsetComponent,\n                            TabHeadingDirective,\n                            NgTranscludeDirective\n                        ]\n                    },] }\n        ];\n        return TabsModule;\n    }());\n\n    exports.NgTranscludeDirective = NgTranscludeDirective;\n    exports.TabDirective = TabDirective;\n    exports.TabHeadingDirective = TabHeadingDirective;\n    exports.TabsModule = TabsModule;\n    exports.TabsetComponent = TabsetComponent;\n    exports.TabsetConfig = TabsetConfig;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n"]}