/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, ElementRef, RendererFactory2, Inject, PLATFORM_ID, NgZone } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { positionElements } from './ng-positioning';
import { fromEvent, merge, of, animationFrameScheduler, Subject } from 'rxjs';
/**
 * @record
 */
import * as ɵngcc0 from '@angular/core';
export function PositioningOptions() { }
if (false) {
    /**
     * The DOM element, ElementRef, or a selector string of an element which will be moved
     * @type {?|undefined}
     */
    PositioningOptions.prototype.element;
    /**
     * The DOM element, ElementRef, or a selector string of an element which the element will be attached to
     * @type {?|undefined}
     */
    PositioningOptions.prototype.target;
    /**
     * A string of the form 'vert-attachment horiz-attachment' or 'placement'
     * - placement can be "top", "bottom", "left", "right"
     * not yet supported:
     * - vert-attachment can be any of 'top', 'middle', 'bottom'
     * - horiz-attachment can be any of 'left', 'center', 'right'
     * @type {?|undefined}
     */
    PositioningOptions.prototype.attachment;
    /**
     * A string similar to `attachment`. The one difference is that, if it's not provided,
     * `targetAttachment` will assume the mirror image of `attachment`.
     * @type {?|undefined}
     */
    PositioningOptions.prototype.targetAttachment;
    /**
     * A string of the form 'vert-offset horiz-offset'
     * - vert-offset and horiz-offset can be of the form "20px" or "55%"
     * @type {?|undefined}
     */
    PositioningOptions.prototype.offset;
    /**
     * A string similar to `offset`, but referring to the offset of the target
     * @type {?|undefined}
     */
    PositioningOptions.prototype.targetOffset;
    /**
     * If true component will be attached to body
     * @type {?|undefined}
     */
    PositioningOptions.prototype.appendToBody;
}
export class PositioningService {
    /**
     * @param {?} ngZone
     * @param {?} rendererFactory
     * @param {?} platformId
     */
    constructor(ngZone, rendererFactory, platformId) {
        this.update$$ = new Subject();
        this.positionElements = new Map();
        this.isDisabled = false;
        if (isPlatformBrowser(platformId)) {
            ngZone.runOutsideAngular((/**
             * @return {?}
             */
            () => {
                this.triggerEvent$ = merge(fromEvent(window, 'scroll', { passive: true }), fromEvent(window, 'resize', { passive: true }), 
                /* tslint:disable-next-line: deprecation */
                of(0, animationFrameScheduler), this.update$$);
                this.triggerEvent$.subscribe((/**
                 * @return {?}
                 */
                () => {
                    if (this.isDisabled) {
                        return;
                    }
                    this.positionElements
                        /* tslint:disable-next-line: no-any */
                        .forEach((/**
                     * @param {?} positionElement
                     * @return {?}
                     */
                    (positionElement) => {
                        positionElements(_getHtmlElement(positionElement.target), _getHtmlElement(positionElement.element), positionElement.attachment, positionElement.appendToBody, this.options, rendererFactory.createRenderer(null, null));
                    }));
                }));
            }));
        }
    }
    /**
     * @param {?} options
     * @return {?}
     */
    position(options) {
        this.addPositionElement(options);
    }
    /**
     * @return {?}
     */
    get event$() {
        return this.triggerEvent$;
    }
    /**
     * @return {?}
     */
    disable() {
        this.isDisabled = true;
    }
    /**
     * @return {?}
     */
    enable() {
        this.isDisabled = false;
    }
    /**
     * @param {?} options
     * @return {?}
     */
    addPositionElement(options) {
        this.positionElements.set(_getHtmlElement(options.element), options);
    }
    /**
     * @return {?}
     */
    calcPosition() {
        this.update$$.next();
    }
    /**
     * @param {?} elRef
     * @return {?}
     */
    deletePositionElement(elRef) {
        this.positionElements.delete(_getHtmlElement(elRef));
    }
    /**
     * @param {?} options
     * @return {?}
     */
    setOptions(options) {
        this.options = options;
    }
}
PositioningService.ngInjectableDef = ɵngcc0.ɵɵdefineInjectable({ token: PositioningService, factory: function PositioningService_Factory(t) { return new (t || PositioningService)(ɵngcc0.ɵɵinject(NgZone), ɵngcc0.ɵɵinject(RendererFactory2), ɵngcc0.ɵɵinject(PLATFORM_ID)); }, providedIn: null });
/*@__PURE__*/ ɵngcc0.ɵsetClassMetadata(PositioningService, [{
        type: Injectable
    }], function () { return [{ type: NgZone }, { type: RendererFactory2 }, { type: Number, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }]; }, { constructor: [], update$$: [], positionElements: [], isDisabled: [], triggerEvent$: [], position: [], event$: [], disable: [], enable: [], addPositionElement: [], calcPosition: [], deletePositionElement: [], setOptions: [], options: [] });
/** @nocollapse */
PositioningService.ctorParameters = () => [
    { type: NgZone },
    { type: RendererFactory2 },
    { type: Number, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    PositioningService.prototype.options;
    /**
     * @type {?}
     * @private
     */
    PositioningService.prototype.update$$;
    /**
     * @type {?}
     * @private
     */
    PositioningService.prototype.positionElements;
    /**
     * @type {?}
     * @private
     */
    PositioningService.prototype.triggerEvent$;
    /**
     * @type {?}
     * @private
     */
    PositioningService.prototype.isDisabled;
}
/**
 * @param {?} element
 * @return {?}
 */
function _getHtmlElement(element) {
    // it means that we got a selector
    if (typeof element === 'string') {
        return document.querySelector(element);
    }
    if (element instanceof ElementRef) {
        return element.nativeElement;
    }
    return element;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImM6L1VzZXJzL3ZhaGVybWloL2tvb2xpdHVzZWQvQW5ndWxhci0wMy0yMDIyL2FuZ3VsYXItYmFrZXJ5c2hvcC9ub2RlX21vZHVsZXMvbmd4LWJvb3RzdHJhcC9wb3NpdGlvbmluZy9lc20yMDE1L3Bvc2l0aW9uaW5nLnNlcnZpY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7OztBQVdBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FzSUMsc1FBR0MiLCJmaWxlIjoicG9zaXRpb25pbmcuc2VydmljZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVvdmVydmlldyBhZGRlZCBieSB0c2lja2xlXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXMsZXh0cmFSZXF1aXJlLG1pc3NpbmdPdmVycmlkZSxtaXNzaW5nUmV0dXJuLHVudXNlZFByaXZhdGVNZW1iZXJzLHVzZWxlc3NDb2RlfSBjaGVja2VkIGJ5IHRzY1xuICovXG5pbXBvcnQgeyBJbmplY3RhYmxlLCBFbGVtZW50UmVmLCBSZW5kZXJlckZhY3RvcnkyLCBJbmplY3QsIFBMQVRGT1JNX0lELCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IHBvc2l0aW9uRWxlbWVudHMgfSBmcm9tICcuL25nLXBvc2l0aW9uaW5nJztcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIG9mLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuLyoqXG4gKiBAcmVjb3JkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBQb3NpdGlvbmluZ09wdGlvbnMoKSB7IH1cbmlmIChmYWxzZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBET00gZWxlbWVudCwgRWxlbWVudFJlZiwgb3IgYSBzZWxlY3RvciBzdHJpbmcgb2YgYW4gZWxlbWVudCB3aGljaCB3aWxsIGJlIG1vdmVkXG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIFBvc2l0aW9uaW5nT3B0aW9ucy5wcm90b3R5cGUuZWxlbWVudDtcbiAgICAvKipcbiAgICAgKiBUaGUgRE9NIGVsZW1lbnQsIEVsZW1lbnRSZWYsIG9yIGEgc2VsZWN0b3Igc3RyaW5nIG9mIGFuIGVsZW1lbnQgd2hpY2ggdGhlIGVsZW1lbnQgd2lsbCBiZSBhdHRhY2hlZCB0b1xuICAgICAqIEB0eXBlIHs/fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBQb3NpdGlvbmluZ09wdGlvbnMucHJvdG90eXBlLnRhcmdldDtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyBvZiB0aGUgZm9ybSAndmVydC1hdHRhY2htZW50IGhvcml6LWF0dGFjaG1lbnQnIG9yICdwbGFjZW1lbnQnXG4gICAgICogLSBwbGFjZW1lbnQgY2FuIGJlIFwidG9wXCIsIFwiYm90dG9tXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJcbiAgICAgKiBub3QgeWV0IHN1cHBvcnRlZDpcbiAgICAgKiAtIHZlcnQtYXR0YWNobWVudCBjYW4gYmUgYW55IG9mICd0b3AnLCAnbWlkZGxlJywgJ2JvdHRvbSdcbiAgICAgKiAtIGhvcml6LWF0dGFjaG1lbnQgY2FuIGJlIGFueSBvZiAnbGVmdCcsICdjZW50ZXInLCAncmlnaHQnXG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIFBvc2l0aW9uaW5nT3B0aW9ucy5wcm90b3R5cGUuYXR0YWNobWVudDtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyBzaW1pbGFyIHRvIGBhdHRhY2htZW50YC4gVGhlIG9uZSBkaWZmZXJlbmNlIGlzIHRoYXQsIGlmIGl0J3Mgbm90IHByb3ZpZGVkLFxuICAgICAqIGB0YXJnZXRBdHRhY2htZW50YCB3aWxsIGFzc3VtZSB0aGUgbWlycm9yIGltYWdlIG9mIGBhdHRhY2htZW50YC5cbiAgICAgKiBAdHlwZSB7P3x1bmRlZmluZWR9XG4gICAgICovXG4gICAgUG9zaXRpb25pbmdPcHRpb25zLnByb3RvdHlwZS50YXJnZXRBdHRhY2htZW50O1xuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIG9mIHRoZSBmb3JtICd2ZXJ0LW9mZnNldCBob3Jpei1vZmZzZXQnXG4gICAgICogLSB2ZXJ0LW9mZnNldCBhbmQgaG9yaXotb2Zmc2V0IGNhbiBiZSBvZiB0aGUgZm9ybSBcIjIwcHhcIiBvciBcIjU1JVwiXG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIFBvc2l0aW9uaW5nT3B0aW9ucy5wcm90b3R5cGUub2Zmc2V0O1xuICAgIC8qKlxuICAgICAqIEEgc3RyaW5nIHNpbWlsYXIgdG8gYG9mZnNldGAsIGJ1dCByZWZlcnJpbmcgdG8gdGhlIG9mZnNldCBvZiB0aGUgdGFyZ2V0XG4gICAgICogQHR5cGUgez98dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIFBvc2l0aW9uaW5nT3B0aW9ucy5wcm90b3R5cGUudGFyZ2V0T2Zmc2V0O1xuICAgIC8qKlxuICAgICAqIElmIHRydWUgY29tcG9uZW50IHdpbGwgYmUgYXR0YWNoZWQgdG8gYm9keVxuICAgICAqIEB0eXBlIHs/fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBQb3NpdGlvbmluZ09wdGlvbnMucHJvdG90eXBlLmFwcGVuZFRvQm9keTtcbn1cbmV4cG9ydCBjbGFzcyBQb3NpdGlvbmluZ1NlcnZpY2Uge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gbmdab25lXG4gICAgICogQHBhcmFtIHs/fSByZW5kZXJlckZhY3RvcnlcbiAgICAgKiBAcGFyYW0gez99IHBsYXRmb3JtSWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUsIHJlbmRlcmVyRmFjdG9yeSwgcGxhdGZvcm1JZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSQkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmlzRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlzUGxhdGZvcm1Ccm93c2VyKHBsYXRmb3JtSWQpKSB7XG4gICAgICAgICAgICBuZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKC8qKlxuICAgICAgICAgICAgICogQHJldHVybiB7P31cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50JCA9IG1lcmdlKGZyb21FdmVudCh3aW5kb3csICdzY3JvbGwnLCB7IHBhc3NpdmU6IHRydWUgfSksIGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnLCB7IHBhc3NpdmU6IHRydWUgfSksIFxuICAgICAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGVwcmVjYXRpb24gKi9cbiAgICAgICAgICAgICAgICBvZigwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlciksIHRoaXMudXBkYXRlJCQpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50JC5zdWJzY3JpYmUoKC8qKlxuICAgICAgICAgICAgICAgICAqIEByZXR1cm4gez99XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkVsZW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWFueSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goKC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gez99IHBvc2l0aW9uRWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgKHBvc2l0aW9uRWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25FbGVtZW50cyhfZ2V0SHRtbEVsZW1lbnQocG9zaXRpb25FbGVtZW50LnRhcmdldCksIF9nZXRIdG1sRWxlbWVudChwb3NpdGlvbkVsZW1lbnQuZWxlbWVudCksIHBvc2l0aW9uRWxlbWVudC5hdHRhY2htZW50LCBwb3NpdGlvbkVsZW1lbnQuYXBwZW5kVG9Cb2R5LCB0aGlzLm9wdGlvbnMsIHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBwb3NpdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYWRkUG9zaXRpb25FbGVtZW50KG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGdldCBldmVudCQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXJFdmVudCQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gez99XG4gICAgICovXG4gICAgZGlzYWJsZSgpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIHRoaXMuaXNEaXNhYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGFkZFBvc2l0aW9uRWxlbWVudChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMucG9zaXRpb25FbGVtZW50cy5zZXQoX2dldEh0bWxFbGVtZW50KG9wdGlvbnMuZWxlbWVudCksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGNhbGNQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGUkJC5uZXh0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P30gZWxSZWZcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIGRlbGV0ZVBvc2l0aW9uRWxlbWVudChlbFJlZikge1xuICAgICAgICB0aGlzLnBvc2l0aW9uRWxlbWVudHMuZGVsZXRlKF9nZXRIdG1sRWxlbWVudChlbFJlZikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez99IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHs/fVxuICAgICAqL1xuICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbn1cblBvc2l0aW9uaW5nU2VydmljZS5kZWNvcmF0b3JzID0gW1xuICAgIHsgdHlwZTogSW5qZWN0YWJsZSB9XG5dO1xuLyoqIEBub2NvbGxhcHNlICovXG5Qb3NpdGlvbmluZ1NlcnZpY2UuY3RvclBhcmFtZXRlcnMgPSAoKSA9PiBbXG4gICAgeyB0eXBlOiBOZ1pvbmUgfSxcbiAgICB7IHR5cGU6IFJlbmRlcmVyRmFjdG9yeTIgfSxcbiAgICB7IHR5cGU6IE51bWJlciwgZGVjb3JhdG9yczogW3sgdHlwZTogSW5qZWN0LCBhcmdzOiBbUExBVEZPUk1fSUQsXSB9XSB9XG5dO1xuaWYgKGZhbHNlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQb3NpdGlvbmluZ1NlcnZpY2UucHJvdG90eXBlLm9wdGlvbnM7XG4gICAgLyoqXG4gICAgICogQHR5cGUgez99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBQb3NpdGlvbmluZ1NlcnZpY2UucHJvdG90eXBlLnVwZGF0ZSQkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9zaXRpb25pbmdTZXJ2aWNlLnByb3RvdHlwZS5wb3NpdGlvbkVsZW1lbnRzO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9zaXRpb25pbmdTZXJ2aWNlLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQkO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHs/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgUG9zaXRpb25pbmdTZXJ2aWNlLnByb3RvdHlwZS5pc0Rpc2FibGVkO1xufVxuLyoqXG4gKiBAcGFyYW0gez99IGVsZW1lbnRcbiAqIEByZXR1cm4gez99XG4gKi9cbmZ1bmN0aW9uIF9nZXRIdG1sRWxlbWVudChlbGVtZW50KSB7XG4gICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBnb3QgYSBzZWxlY3RvclxuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudFJlZikge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbiJdfQ==